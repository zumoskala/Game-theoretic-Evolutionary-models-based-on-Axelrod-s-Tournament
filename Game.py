# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mQahQSH8VSEmj4hds1QZLxF3t5i6TAV2
"""

from random import *
import evolutionaryAlgorithm as ea
 
move = ['H','D']  # H : Hawk, D: Dove
 
def gain(player1, player2):
	return {
		("D", "D") : 2,
		("D", "H") : 0,
		("H", "D") : 4,
		("H", "H") : -1,
	}[player1, player2]
 
 
# ALLC - A player who only ever plays Dove.
 
def ALLC(list_player1,list_player2):
    return 'D'
 
# ALNC - A player who only ever plays Hawk.

def ALNC(list_player1,list_player2):
    return 'H'
 
 
# Random - A player who randomly chooses between playing Dove and Hawk.
import random
 
def Random(list_player1,list_player2):
    return random.choice(['D','H'])
 
 
# Tit for Tat - A player starts by playing Dove and then mimics previous move by opponent.
 
def TFT(list_player1,list_player2):
    if len(list_player1)>0:
        return list_player1[-1]
    else:  # first move
        return 'D'

# Anti-Tit for Tat - A player starts by playing Hawk and then mimics previous move by opponent. 

def ATFT(list_player1,list_player2):
    if len(list_player1)>0:
        return list_player1[-1]
    else:  # first move
        return 'H'

# Opposite Tit For Tat - A player starts by playing Hawk on the first round, then does the opposite of the other player's last move.

def OppositeTFT(list_player1,list_player2):
    return 'D' if list_player1[-1:] == ['H'] else 'H'

# Grudger - A player starts by playing Dove however will play Hawk if at any point the opponent has played Hawk.
 
def Grudger(list_player1,list_player2):
    if 'H' in list_player1:
        return 'H'
    else:
        return 'D'

def EvolutionaryAlg(list_player1,list_player2):
    player = ea.EvolutionaryPlayer()
    return player.playAxelrod(list_player1)

# Tournament 
list = {}
strategy = {}
score = {}
duel = {}
 
list['ALLC'] = []
list['ALNC'] = []
list['Random'] = []
list['Grudger'] = []
list['TFT'] = []
list['ATFT'] = []
list['OppositeTFT'] = []
list['EvolutionaryAlg'] = []
 
strategy['ALLC'] = lambda player1, player2 : ALLC(player1,player2)
strategy['ALNC'] = lambda player1, player2 : ALNC(player1,player2)
strategy['Grudger'] = lambda player1, player2 : Grudger(player1,player2)
strategy['Random'] = lambda player1, player2 : Random(player1,player2)
strategy['TFT'] = lambda player1, player2 : TFT(player1,player2)
strategy['ATFT'] = lambda player1, player2 : ATFT(player1,player2)
strategy['OppositeTFT'] = lambda player1, player2 : OppositeTFT(player1,player2)
strategy['EvolutionaryAlg'] = lambda player1, player2 : EvolutionaryAlg(player1,player2)

 
nb_total_rounds = 1000 
 
for player in list.keys():
    score[player] = 0

for i in list.keys():
    for j in list.keys() :
        list[i] = []
        list[j] = []
        list_player1 = []
        list_player2 = []
        if i>=j:
            nb_rounds = 0
            score_player1 = 0
            score_player2 = 0
            seed(45226)
            while nb_rounds < nb_total_rounds :
                move_player1 = strategy[i](list[j],list[i])
                move_player2 = strategy[j](list[i],list[j])
                list[i].append(move_player1)
                if i!=j:
                    list[j].append(move_player2)
                score_player1 += gain(move_player1,move_player2)
                score_player2 += gain(move_player2,move_player1)
                list_player1.append(gain(move_player1,move_player2))
                list_player2.append(gain(move_player2,move_player1))
                nb_rounds += 1

            duel[(i,j)] = score_player1
            if i!=j:
                duel[(j,i)] = score_player2
            score[i] += score_player1
            if i!=j:
                score[j] += score_player2


            duel[(i,j)] = list_player1
            if i!=j:
                duel[(j,i)] = list_player2
            list[i] += list_player1
            if i!=j:
                list[j] += list_player2

# results
 
def sort_by_value(d):
    return sorted(d.items(), key=lambda x: x[1])
 
def sort_by_key(d):
    return sorted(d.items(), key=lambda x: x[0])
 
score_sorted = sort_by_value(score)
score_sorted.reverse()
for i in range(0,len(score_sorted)):
    print(score_sorted[i][0],":",score_sorted[i][1])
print()
duel_sorted = sort_by_key(duel)
for i in range(0, len(duel_sorted)):
    print(duel_sorted[i][0][0],"vs",duel_sorted[i][0][1],"scored",duel_sorted[i][1],"points")

import matplotlib.pyplot as plt
#results_together = sns.barplot(x="Player", y="Score", hue="Opponent", data=score_sorted, palette="GnBu_d")
#plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
#results_together.set_xticklabels(ax.get_xticklabels(), rotation=40, ha="right")
plt.bar(range(len(score_sorted)), [val[1] for val in score_sorted], align='center', color=(0.2, 0.4, 0.6, 0.6))
plt.xticks(range(len(score_sorted)), [val[0] for val in score_sorted])
plt.xticks(rotation=70)
plt.show()

